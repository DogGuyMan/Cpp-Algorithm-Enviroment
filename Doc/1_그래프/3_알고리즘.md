
---

## ì•Œê³ ë¦¬ì¦˜

---

> ### ğŸ“„ 1 BFS & DFS

#### 1). BFS

* ë‹¨ì ì´ë¼ í•  ê²ƒì€ ì¤‘ë³µëœ ì •ì ì´ Queueì— ë“¤ì–´ê°ˆ ì´ìŠˆê°€ ìˆë‹¤ëŠ”ê²ƒ ì´ë‹¤.
* Edge Classification : ë°©í–¥ ê·¸ë˜í”„ë“ , ë¬´ë°©í–¥ ê·¸ë˜í”„ë“ 
ë‹¤ìŒ í˜•íƒœë¡œ ëª¨ë‘ ë‚˜íƒ€ë‚  ìˆ˜ ìˆë‹¤.
![](image/2025-08-28-03-21-41.png)

```cpp
TreeEdge struct {
	int root;
	vector<int> childs;
}

bool is_visited[MAXV + 1] = {0,};

void BFS(map<int, TreeEdge>& out, int sV) {
	queue<int> q;
	q.push(sV);
	is_visited[sV] = true;
	out[sV].root = sV;

	while(!q.empty()) {
		int cur = q.front(); q.pop();
		for(auto& e : g[cur]) {
			if(!is_visited[e.to]) {
				out[cur].childs.push_back(e.to);
				q.push(e.to);
				is_visited[e.to] = true;
			}
		}
	}

	for(auto& tree : out) {
		tree.root = sV;
	}
}

void LevelBFS(int sV) {
	queue<int> q;
	int level = 0;

	q.push(sV);
	is_visited[sV] = true;

	while(!q.empty()) {
		int level_sz = q.size();

		for(int i = 0; i < level_sz; i++) {
			int cur = q.front();
			q.pop();

			for(auto& e : g[cur]) {
				if(!is_visited[e.to]) {
					q.push(e.to);
					is_visited[e.to] = true;
				}
			}
		}
		level++;
	}
}

// ì‹ ê¸°í•˜ê²Œë„.. O(N + M) ì´ê²ƒë„ ì‹œê°„ ë³µì¡ë„ê°€ ê±¸ë¦°ë‹¤.
// O(N * (N + M))
// ì•„ë§ˆë„ nì„ ìª¼ê°œì„œ n_1, n_2 ì—ì§€ë„ e ìª¼ê°œì„œ e_1, e_2ê°€ ë˜ì„œ
//
void ConnectedComponents() {
    vector<map<int, TreeEdge>> trees;

    // ë°©ë¬¸ ë°°ì—´ ì´ˆê¸°í™”
    fill(is_visited, is_visited + MAX_V + 1, false);

    for(int i = 1; i <= n; i++) {
        if(!is_visited[i]) {
            map<int, TreeEdge> component_tree;
            BFS(component_tree, i);
            trees.push_back(component_tree);
        }
    }
}
```


---

#### 2). DFS

<div align=center>
	<img src="image/2025-08-28-03-04-22.png" width="80%">
	<h5></h5>
</div>

```cpp
bool is_visited[MAXV + 1] = {0,};

void DFS(int sV) {
	is_visited[sV] = true;
	for(auto& e : g[sV]) {
		if(!is_visited[sV]){
			DFS(e.to);
		}
	}
}
```

* Edge Classification : ë°©í–¥ ê·¸ë˜í”„ëŠ” ë°˜ë“œì‹œ
DFS ìˆœíšŒì‹œ ë‚˜íƒ€ë‚˜ëŠ” ê°•ì ì€ ë‹¤ìŒ ë‘ê°€ì§€ì˜ í˜•íƒœë¡œ ìˆœíšŒë˜ëŠ”ê²ƒì´ ë³´ì¥ëœë‹¤.
  | Tree Edges                         | Back Edge                          |
  | ---------------------------------- | ---------------------------------- |
  | ![](image/2025-08-28-03-17-26.png) | ![](image/2025-08-28-03-17-46.png) |
* ì´ë¥¼ ì‘ìš©í•˜ë©´ ì‚¬ì´í´ íƒìƒ‰ì´ ê°€ëŠ¥í•´ ì§„ë‹¤.
  ```cpp
  int parent[MAX_V + 1] = {0,}


  bool DFS(int sV) {
  	is_visited[sV] = true;
	bool flag = false;

  	for(auto& e : g[sV]) {
  		if(!is_visited[sV]){
			parent[e.to] = sV;
  			DFS(e.to);
  		}
		flag = true;
  	}
	return flag
  }
  ```

* í•œë¶“ ê·¸ë¦¬ê¸° ë§ì¹˜ê¸°

> ### ğŸ“„ 2 Dijkstra & Floyd-Warshall

> ### ğŸ“„ 3 Kruskal & Prim

> ### ğŸ“„ 4 Bipartite Graph (ì´ë¶„ ê·¸ë˜í”„)


---

#### 1). íŒë³„ ì•Œê³ ë¦¬ì¦˜ (BFS ê¸°ë°˜)

* ë§Œì•½ BFSë¥¼ ìˆ˜í–‰ì¤‘.
ê°™ì€ ì»¬ëŸ¬ë§ë¼ë¦¬ Edgeê°€ ì¡´ì¬í•œë‹¤ë©´ ì´ë¶„ê·¸ë˜í”„ê°€ ì•„ë‹Œê²ƒì´ë‹¤.

```cpp
enum Color { UNCOLORED = 0, RED = 1, BLUE = 2 };
Color colors[MAX_V + 1];

// ì»¬ëŸ¬ë§í•˜ë©´ì„œ ì¶©ëŒ(ê°™ì€ ìƒ‰ ì¸ì ‘ ì •ì ) ë°œê²¬í•˜ë©´ ì´ë¶„ ê·¸ë˜í”„ê°€ ì•„ë‹˜
bool is_bipartite(int n) {
    fill(colors, colors + n + 1, UNCOLORED);

    for(int start = 1; start <= n; start++) {
        if(colors[start] == UNCOLORED) {
            queue<int> q;
            q.push(start);
            colors[start] = RED;

            while(!q.empty()) {
                int cur = q.front(); q.pop();

                for(auto& e : g[cur]) {
                    if(colors[e.to] == UNCOLORED) {
                        // í˜„ì¬ ì •ì ê³¼ ë‹¤ë¥¸ ìƒ‰ìœ¼ë¡œ ì¹ í•˜ê¸°
                        colors[e.to] = (colors[cur] == RED) ? BLUE : RED;
                        q.push(e.to);
                    }
                    else if(colors[e.to] == colors[cur]) {
                        // ì¸ì ‘í•œ ì •ì ì´ ê°™ì€ ìƒ‰ì´ë©´ ì´ë¶„ ê·¸ë˜í”„ê°€ ì•„ë‹˜
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
```

---

#### 2). ì‹¤ì œ ì˜ˆì‹œ

**ì´ë¶„ ê·¸ë˜í”„ ì˜ˆì‹œ:**
* í•™ìƒ-ê³¼ëª© ê´€ê³„ ê·¸ë˜í”„ (í•™ìƒë¼ë¦¬ëŠ” ì—°ê²° ì—†ìŒ, ê³¼ëª©ë¼ë¦¬ë„ ì—°ê²° ì—†ìŒ)
* ë‚¨ì„±-ì—¬ì„± ë§¤ì¹­ ë¬¸ì œ
* ì²´ìŠ¤íŒì˜ í‘ë°± ì¹¸ë“¤

**ì´ë¶„ ê·¸ë˜í”„ê°€ ì•„ë‹Œ ì˜ˆì‹œ:**
* ì‚¼ê°í˜• (3ê°œ ì •ì ì˜ ì‚¬ì´í´)
* í™€ìˆ˜ ê¸¸ì´ ì‚¬ì´í´ì„ í¬í•¨í•˜ëŠ” ëª¨ë“  ê·¸ë˜í”„

**ì‹œê°„ ë³µì¡ë„:** $O(V + E)$ (BFS í•œ ë²ˆìœ¼ë¡œ íŒë³„ ê°€ëŠ¥)

> ### ğŸ“„ 5 ì‚¬ì´í´ íƒìƒ‰

#### ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ìƒì„±í•˜ê±°ë‚˜, ìœ„ìƒì •ë ¬ì‹œ ì „ì œ ì¡°ê±´ì´ë¯€ë¡œ, í•„ìš”í•˜ë‹¤.

---

#### 1). ë¬´ë°©í–¥ ê·¸ë˜í”„ (Disjoint Set And Union Find)

```cpp

int parent[MAX_V + 1 ] {0,};

void InitializeDisjointSet(int (arr&)[MAX_V + 1], int max_sz) {
	for(int i = 1; i < max_sz; i++)
	{
		arr[i].par = i;
	}
}

// ê²½ë¡œ ì••ì¶•
int Find(int parNode) {
	if(parNode == parent[parNode]) return parNode;
	return Find(parent[parNode]);
}

// Find Cycleì´ë¼ê³  í•˜ê³ , í˜¹ì€ ìœ ë‹ˆì˜¨ê³¼ ì ˆì°¨ê°€ ë¹„ìŠ·í•˜ë‹¤.
void Unite(int x, int y) {
	int xRoot = FindRoot(x);
	int yRoot = FindRoot(y);
	parent[yRoot] = xRoot;
}

bool CheckCycle() {
	InitializeDisjointSet(parent, MAX_V + 1);
	for(int i = 1; i < MAX_V + 1; i++) {
		for(auto& e : g[i]) {
			int sRoot = Find(i);
			int eRoot = Find(e);
			if(sRoot == eRoot) return true;
			else Unite(sRoot, eRoot);
		}
	}
	return false;
}
```

---

#### 2). ë°©í–¥ ê·¸ë˜í”„
* ì¼ëª… Back Edgeë¥¼ íŒë‹¨í•˜ì—¬ ì‚¬ì´í´ì„ ê²€ì¶œí•œë‹¤.

---

> ### ğŸ“„ 6 ìœ„ìƒ ì •ë ¬

#### 1). êµ¬í˜„ ë°©ë²•ë“¤

##### â‘  DFS ê¸°ë°˜ (ì™„ë£Œ ì‹œê°„ ì—­ìˆœ)

* DAG íŒì •ì€, Back Edge (Cycle)ì´ ì—†ë‹¤ê³  íŒì •ë§Œ í•  ìˆ˜ ìˆë‹¤ë©´
ìœ„ìƒ ì •ë ¬ì´ ê°€ëŠ¥í•˜ë‹¨ ì˜ë¯¸ë‹¤.
  * DFSì—ì„œ ìˆœíšŒí–ˆë˜ ê³¼ì •ì„ ë°±íŠ¸ë˜í‚¹í•œë‹¤ë©´ ê·¸ê²Œ ìœ„ìƒì •ë ¬ì˜ ê²°ê³¼ì„.
   DFSê°€ ëŠ¦ê²Œ ì¢…ë£Œí•œ ì •ì ì¼ ìˆ˜ë¡ ìœ„ìƒì •ë ¬ ê²°ê³¼ì˜ ì•ì— ì˜¨ë‹¤.
  * DFS ê¸°ë°˜ ìœ„ìƒ ì •ë ¬ì´ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ëŠ” ì´ìœ 

* DFS ìƒíƒœ ì •ì˜
  1. Undiscovered (ë¯¸ë°œê²¬): ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ìƒíƒœ (í°ìƒ‰)
  2. Discovered (ë°œê²¬ë¨): ë°©ë¬¸í–ˆì§€ë§Œ ì•„ì§ ì²˜ë¦¬ ì¤‘ì¸ ìƒíƒœ (íšŒìƒ‰)
  3. Completed (ì™„ë£Œë¨): ëª¨ë“  í›„ì†ì„ ì²˜ë¦¬í•˜ê³  ì™„ë£Œëœ ìƒíƒœ (ê²€ì€ìƒ‰)

* ê·€ë¥˜ë²•
  * ê³µë¦¬ 
    ```
	ì¢…ë£Œê°€ ê°€ì¥ ë‚˜ì¤‘ì— ëœê²ƒì„ ê°€ì¥ ì™¼ìª½ìœ¼ë¡œ ì •ë ¬í•´ì„œ ë°°ì—´í•œë‹¤.
	u -> v : dfs(v)ê°€ ë¨¼ì €, dfs(u)ëŠ” ë‚˜ì¤‘ì— ìˆ˜í–‰ëœê²ƒìœ¼ë¡œ ìƒê°í•˜ì.
	ex). a -> b -> c -> d -> e ì´ë©´ 
		aê°€ ê°€ì¥ ë‚˜ì¤‘ì— ì¢…ë£Œë˜ê³ 
		eê°€ ê°€ì¥ ë¨¼ì € ì¢…ë£Œëœ ê²ƒì´ë‹¤.
    ```
  * ë§Œì•½ "a -> b -> c -> d -> e"ì—ì„œ
  	e -> a ë¡œ dfsê°€ ìˆ˜í–‰ë˜ì„œ dfs(e)í˜¸ì¶œ ì‹œì‘ dfs(a)ì¢…ë£Œ dfs(e)ê°€ ì¢…ë£Œë˜ì—ˆë‹¤ê³  í–ˆì„ë•Œ.
    * ì´ë–„ Visitì˜ ìƒíƒœëŠ” ë‘˜ë‹¤ ëª¨ìˆœì´ ìˆìŒì„ ë³´ì¸ë‹¤.
      1. `visit[a] == true` ì‚¬ì´í´ì´ ìƒê¸°ë¯€ë¡œ DAGê°€ ëª¨ìˆœ
      2. `visit[a] == false` ê·¸ë ‡ë‹¤ë©´ eëŠ” ì˜¤ë¥¸ìª½ì— ìˆì„ ìˆ˜ê°€ ì—†ìŒ ì• ì´ˆì— ìœ„ìƒ ì •ë ¬ë¡œ ì¸í•´
	  	eëŠ” ê°€ì¥ ì™¼ìª½ì— ìˆì–´ì•¼ í–ˆìŒ

##### â‘¡ Kahn's Algorithm (ì§„ì… ì°¨ìˆ˜ ê¸°ë°˜)

---

#### 2). ì‹¤ì œ í™œìš© ì˜ˆì‹œ

1. **ì‘ì—… ìŠ¤ì¼€ì¤„ë§** : ì˜ˆ: ì˜· ì…ëŠ” ìˆœì„œ
2. **ì»´íŒŒì¼ ìˆœì„œ ê²°ì •** : A.cppê°€ B.hë¥¼ include â†’ Bê°€ Aë³´ë‹¤ ë¨¼ì € ì»´íŒŒì¼ë˜ì–´ì•¼ í•¨


---

#### 3). ì¤‘ìš”í•œ íŠ¹ì„±ë“¤
1. **ìœ ì¼ì„±**
	* ìœ„ìƒ ì •ë ¬ ê²°ê³¼ëŠ” **í•­ìƒ ìœ ì¼í•˜ì§€ ì•ŠìŒ**
	* ì—¬ëŸ¬ ê°œì˜ ì˜¬ë°”ë¥¸ ë‹µì´ ì¡´ì¬í•  ìˆ˜ ìˆìŒ
2. **ì‚¬ì´í´ ê²€ì¶œ**
    ```cpp
    // Kahn's: result.size() != n ì´ë©´ ì‚¬ì´í´ ì¡´ì¬
    // DFS: Back Edge ë°œê²¬í•˜ë©´ ì‚¬ì´í´ ì¡´ì¬
    ```
3. **DAG ì¡°ê±´**
	* **ë°©í–¥ ê·¸ë˜í”„** (ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œëŠ” ì˜ë¯¸ì—†ìŒ)
	* **ë¹„ì‚¬ì´í´** (ì‚¬ì´í´ ìˆìœ¼ë©´ ë¶ˆê°€ëŠ¥)


