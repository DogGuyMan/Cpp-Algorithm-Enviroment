```cpp
using pii = std::pair<int,int>; // 가독성을 위해 X/Y 매크로는 지양
std::vector<pii> A;

// 1) X 내림차순, X 같으면 Y 오름차순
std::sort(A.begin(), A.end(), [](const pii& a, const pii& b){
    if (a.first != b.first) return a.first > b.first;
    return a.second < b.second;
});

// 2) 그냥 사전식(기본 비교)면 람다도 불필요
std::sort(A.begin(), A.end()); // first↑, tie에선 second↑

```

```cpp
// A) second↑, tie에선 first↓
std::sort(A.begin(), A.end(), [](const pii& a, const pii& b){
    if (a.second != b.second) return a.second < b.second;
    return a.first  > b.first;
});

// B) 인덱스 정렬: 값이 담긴 arr 기준으로 idx 정렬
std::vector<int> idx(n); std::iota(idx.begin(), idx.end(), 0);
std::sort(idx.begin(), idx.end(), [&](int i, int j){
    if (arr[i] != arr[j]) return arr[i] < arr[j];
    return i < j; // 안정 tie-break
});

// C) 우선순위 큐(다익스트라 등): dist 작은 게 높은 우선순위
auto cmp = [&](int i, int j){ return dist[i] > dist[j]; };
std::priority_queue<int, std::vector<int>, decltype(cmp)> pq(cmp);

// D) lower_bound용 이형 비교: struct 벡터에서 x로 탐색
struct P{int x,y;};
std::vector<P> v;
std::sort(v.begin(), v.end(), [](const P& a, const P& b){ return a.x < b.x; });
auto it = std::lower_bound(v.begin(), v.end(), 10,
    [](const P& a, int key){ return a.x < key; });

// E) 재귀 람다(DFS/BFS 유틸)
auto dfs = [&](auto&& self, int u)->void{
    vis[u]=1;
    for(int v: G[u]) if(!vis[v]) self(self, v);
};
dfs(dfs, 0);
```