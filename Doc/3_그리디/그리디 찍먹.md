## 그리디 찍먹

* 그리디를 각잡고 공부하는 마음가짐은 아니고, 
아니, 사실 알고리즘을 각잡고 공부해 본 적이 없기 떄문에 
기본 지식으로 여태 풀었다만, 가장 약한 부분인 그리디를 한번 찍먹이라도 해보자는 느낌으로 공부해 보자.
* [나정휘](https://justiceHui.github.io) 님의 교육 목차를 따라가 볼 것이다.

귀류법 \# 이산수학
```
귀류법 : 
    원래 명제가 '참'임을 증명하기위해 
    그 명제가 부정이라고 '가정했을때, 모순이 발생함'을 이용하자

맹목적으로 답을 찾아 나가고, 그게 최적해라는 것을 이용한 알고리즘인데.
왜 귀류법을 쓰는거지?
1. 맹목적이라서? -> 이건 아닌 것 같다.
2. 최적해라는 것이 보장되야 해서? -> 맞다 맹목적으로 수행하는게 최적해라는것을 증명해야 하기 떄문에 귀류법을 쓰는 것 같다.

증명법과 관련된 용어
    pf, lemma

그럼 최적해임을 증명하는 벙이 어떻게 적용되지?
    1.  sqrt(2)가 유리수가 아님을 증명하는것
        sqrt(3)가 유리수가 아님을 증명하는것
    3.  소수는 무한이 많음을 증명 
        4n+3꼴의 소수는 무한이 많음을 증명 
    5.  n > 1인 정수의 소인수 분해가 유일함을 증명 
        강한 수학적 귀납법을 이용해 증명

강한 수학적 귀납법은 모두 증명을 해야한다는 것 인가?

이 두가지 어느거도 최적해랑 관련 없어 보이는데..
그러면 그리디에 대한 내 가정 (맹목적으로 답을 찾아 나가고, 그게 최적해라는 것을 이용한 알고리즘)이 잘못된건가?

Q1). 그럼 최적해임을 증명하는 법이 이산수학 귀류법이랑 관련 있나? 
    if YES Q). 어떻게 적용되지?
        A보다 좋은(최대/최소) 최적해 B가 없음을 증명
        A보다 좋은(최대/최소) 최적해 B가 항상 있다고 가정한 뒤, B가 최적해가 아님을 보임
        원소의 우선순위를 정한뒤, 우선순위가 높은 것부터 선택하는게 최적임을 보임
        어떤 원소를 포함하는 최적해가 항상 존재함을 보임 
            (종료시간이 가장 빠른 회의 m을 포함하지 않는 최적해 O가 존재한다 가정하고) m을 포함하지 않은 최적해가 없음을 
            O에서 가장 빠른 회의를 하나 지우고 m을 넣은 O'이 존재
            O'이 알고보니 더 빨랐다는 것을 증명
        현재까지 만든 F를 포함하는 최소 스패닝 트리 T가 존재 할 때, F와 V-F를 연결하는 간선 e를 포함한
            F+e를 포함한 최소 신장 트리가 T'가 또 있는지 증명
Q2). 그러면 그리디에 대한 내 가정 (맹목적으로 답을 찾아 나가고, 그게 최적해라는 것을 이용한 알고리즘)이 잘못된건가?
    NO 내 가정이 맞다.
```

그리디
```
탐욕법
현재 상태에서 가장 좋을 것 같은 선택을 함 
    당연히 모든문제를 그리디로 풀 수는 없다. 최적해라는 보장이 되야 하기 때문이다.
    풀이가 대부분 "가장 큰~~", "가장 긴~~", "가장 빠른~~"부터 뭔가 해나가라는 것이다 보니 
    복잡한 사용자 정의 구조체나 클래스 정렬 기술은 필수입니다.
        Local Optimum VS Global Optimum은 다르기 때이다.
    이러한 전략이 전체 범위에서도 최적이라면 그떄는 그리디 알고리즘으로 풀 수 있다.

그래서. 전략을 세우고, 풀이의 정당성을 증명하는 과정이 필수적이고
    풀이의 정당성 증명 과정은 귀류법을 이용한 것 같다.
        말고도 exchange argument, greedy stays ahead, certificate argument 증명과 풀이가 가능하다
    우선은 "그럴듯한" 풀이를 떠올려본 뒤에 이를 코드로 옮겨서 AC를 받고, 나중에 증명을 해보는 것도 괜찮습니다.

그리디의 일반적인 형태
    A집합의 개의 원소가 주어짐, RES ⊆ A 인 정답을 저장하는 RES집합도 있음
    Feasible함을 판정하는 함수를 만들고 RES집합에 A원소 하나 추가해도 Feasible한지를
        맞냐 틀리냐 이분적인 상태로 그~~냥 루프를 돌린다. O(n * FeasibleTime) < O(nlog₂n) < O(n²)
     그리디 알고리즘은 후퇴하지 않습니다. 한번 잘못된 선택을 했다고 해서 그 수를 무르지 않습니다.

맹목적이라는 것은 내가 생각하기에 전제 조건이 있기도 한 것 같다.
    1. 완전 무작위 자료
    2. 정렬된 자료

그리디가 풀 수 없는 문제
    0/1 Knapsack Problem : 그리디 전략이 통하지 않는다.
    Fractional Knapsack Problem은 간으하다.

```

그리디 + 우선순위 큐(이진힙)

```
트리 자료구조에 대해 다시 배우면 된다.
    최소 신장트리 (프림 알고리즘, 등등..)
    Spanning Tree
이진 힙 외에도 다양한 힙 자료구조가 있음
허프만 코드
Prefix COde
```

---

## 참고

* [라이 : 탐욕적 기법(Greedy Algorithm) (수정: 2019-11-23)](https://blog.naver.com/jinhan814/222609762108?)
* [박진한 : Theme 10. 그리디 - (1)](https://blog.naver.com/jinhan814/222609762108?)
* [알고리즘 중급 1/3](https://code.plus/course/43)
* [나정휘](https://justiceHui.github.io)
  * https://github.com/justiceHui/Sunrin-SHARC/tree/master/2021-1st
  * https://github.com/justiceHui/SSU-SCCC-Study/tree/master/2023-summer-basic/slide
  * [그리디 + 우선순위 큐 & 그리디 + 메트로이드 & 서로소 집합](https://github.com/justiceHui/SSU-SCCC-Study/blob/master/uncategorized-slides)