// XOR 했을때 0이 되는 경우 두 거리가 같아야 한다.
// 1111
// 0011
// 0100
// 0111
// 좋은 시작점을 찾아야 한다. -> 그리디하게 알수는 없다.
// 모든 시작점에서부터 시작해야 한다.
// 수학적인 접근을 해야하나?
// 한번 사용한 간선을 다시 못쓰도록 할수는 없다.
// 초기에 미리 0을 카운트하자
// 카운트 하고 0이 되는식으로 하면된다.
// 아냐 그렇게 해도 안된다 
// 8 7 3
// 7 6 3
// 6 3 3
// 에서 8 7 7 6 해도
// 어쨌든 한 라인에 있던것은 없에긴 해야해 -> 아냐 없엘수 없어,

### 핵심 아이디어는..

바로 XOR 간 연산이 0이 된다는것은 A -> ?? -> B
에서 두 -> 의 값이 동일하다는 것이고,

수많은 A -> ?? -> ||N|| 이 존재할것이고,
그러한 값이 둘이 쌍을 맞추는 요소끼리 조합을 사용하면 된다는것이였다.

그리고 그러한 경로를 계산하는데 있어 DFS는 한번만 돌려도 되는것이였고,