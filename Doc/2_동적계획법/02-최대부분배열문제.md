### Kadane’s algorithm

* `cur = max(0, cur) + a[i]`
* `best = max(best, cur)`
* 초기값 SUM[0] = 0

### 3개 값 분할정복 

* 구간을 둘로 쪼개어 `LeftBest`, `RightBest`를 만든다
* 마지막으로 `CrossBest`라는 것을 `CrossBest = maxSuffix(left) + maxPrefix(right)`; 으로 계산한다.
* 잘 없다, 교육용 이해로, 서그먼트 트리 합병 로직의 기반이다.

### 세그먼트 트리

* 노드에 4개값 저장 `{sum, pref, suff, ans}`;
* 병합 규칙
  ```
  Node l, Node r;
  sum = l.sum + r.sum;
  pref = max(l.pref, l.sum + r.pref);
  suff = max(r.suff, r.sum + l.suff);
  ans = max({l.ans, r.ans, l.suff + r.pref});
  ```
* 구간 최대 부분합 쿼리, 점 갱신이 많은 경우

### 누적합 + 최소 prefix 추적

* `pref[i] = accumulate(a, a+i, 0)`
* $\text{최대 부분합} = max(mx, S[i] - min(minPref, S[i])$

### 누적합+최소 prefix 과 Kadane’s algorithm의 동치 관계
* “시작점을 i 자체로 택함”과 “이전 최적에 a[i]를 연장”에 대응.

---

```cpp
SUM[0] = 0;
SUM[k] = accumulate(a, a+k, 0);

// j <= i 인 a[j] + a[j+1] + ... + a[i] 에서 값을 최대화 하려면
// a[0] + a[1]+ ... + a[j] 이 최소인것을 
// a[0] + a[1]+ ... + a[i] 가 최대인것과 빼면 된다.
```