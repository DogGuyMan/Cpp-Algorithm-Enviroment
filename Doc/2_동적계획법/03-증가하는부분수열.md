### "증가하는 수열" + "부분 수열"

부분 수열 : 수열의 원소 볓개를 선택해서, 순서를 유지한 채로 만든 새로운 수열
증가하는 수열 : `A[i-1] < A[i]`를 만족하는 수열

### 동적 계획법 풀이

$DP[i]$ `A[i]` 까지 사용해서 가장 길었던 수
초기값 `DP[1] = 1`

#### 이렇게 하면 오늘만 살겠다는 의미..

* 이게 안통하는 숭간은 999 1 2 3 4 5 6 7 8 9 10 1000 일떄 안통한다.
  ```cpp
  int prev = 1;
  DP[1] = 1;
  FOR(i, 1, N+1) { 
      if(A[prev] < A[i]) {
          DP[i] = max(DP[i], DP[prev] + 1);
          prev = i;
      }
  }
  ```

#### 모든 시작점 기준으로 돌려야함.
```cpp
void HandleInput(istream &ins)
{
	ins >> N;
	FOR(i, 1, N + 1) { ins >> A[i]; }
	int res = -MAX;
	FOR(i, 1, N + 1)
	{
		DP[i] = 1;
		FOR(j, 1, i)
		{
			if (A[j] < A[i]) DP[i] = max(DP[i], DP[j] + 1);
		}
		res = max(res, DP[i]);
	}

	cout << res << '\n';
}
```

#### 마지막 값을 `A[i]`로 사용했을떄 최대 길이
  단점은 음수에서는 사용 불가능 하다는것이다.
```cpp
const int MAX = 1e3 * 1e3;
int N;
int A[1010] = { 0,};
int DP[1010] = { 0,};

void main()
{
	ins >> N;
	FOR(i, 1, N + 1) { ins >> A[i]; }
	FOR(i, 1, N + 1)
	{
		FOR(j, 0, A[i]) {
			DP[A[i]] = max(DP[A[i]], DP[j] + 1);
		}
		for(int i = 0; i <= 51; i++) { cout << DP[i] << ' '; } cout << '\n'; // DEBUG
	}
	int res = -MAX;
	for(int i = 0; i < 1010; i++) {res = max(res, DP[i]);}
	cout << res << '\n';
}
```

```bash
> 12
31 1 2 3 4 5 6 7 8 9 10 51

>   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 11 
    11

> 11
-1 -2 3 4 5 6 7 8 9 10 51

>   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
    0 0 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 
    9
```

### 이분탐색 기법, Patience sorting

* 음수도 가능하다.

```cpp
vector<int> A;

void main()
{
	cin >> N;
	A.push_back(-MAX);
	FOR(i, 0, N) {
		int cur; cin >> cur;
		if(A.back() < cur)
			A.push_back(cur);
		else {
            // 덮어 씌우기 연산임.
			auto it = lower_bound(A.begin(), A.end(), cur);
			*it = cur;
		}
		for(auto& e : A) { if(e == -MAX){ continue;} cout << e << ' ';} cout << '\n'; //DEUBG
	}
	cout << A.size() << '\n';
}
```

```shell
>  11
51 43 44 45 46 1 2 3 4 5 6 

>   51 
    43 
    43 44 
    43 44 45 
    43 44 45 46 
    1 44 45 46 
    1 2 45 46 
    1 2 3 46 
    1 2 3 4 
    1 2 3 4 5 
    1 2 3 4 5 6 
    7
```

```shell
>   9
51 43 44 45 46 1 2 3 4

>   51 
    43 
    43 44 
    43 44 45 
    43 44 45 46 
    1 44 45 46 
    1 2 45 46 
    1 2 3 46 
    1 2 3 4 
    5
```

```shell
> 7
51 43 44 45 46 1 2

>   51 
    43 
    43 44 
    43 44 45 
    43 44 45 46 
    1 44 45 46 
    1 2 45 46 
    5
```
