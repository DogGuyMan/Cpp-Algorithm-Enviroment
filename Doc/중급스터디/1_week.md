
---

## 1주차

---


> ### 📄 1. Bit DP

비트 필드를 사용한 DP `bitset`?
대표적으로 외판원 순회 문제
```
그래프 DP : 어디서 시작해서 최소 경로로 다 순회할지 몰라 다 구하는거.
뭐가.. 순회 방법이 n!란다.

5개 있다고 치자 마을이
00000 // 미방문
00010 // 4번째 마을 방문
01010 // 4번째 이후 2마을 방문

근데 이게 뭐 DP 인것도 아니고, 걍 n! 한거랑 다를바가 없잖아..
```

#### 1). 비트 배열을 DP로 쓰기.

어쨌든 비효율적인 원소 저장을 줄이겠다는 의미다.

DP[3][010011(방문 상태)] = 이게 최솟값

```cpp
DP[N][bit]

최종값은..
for(int i = 0; i <= N; i++) {
    for(int j = 0; j <= 2<<n; j++) {
        DP[i][j] 이거의 최대값 구하기.
    }
}

혹은..
DP[N][11111111...1111] 룰 리턴한다.

DP[i][2^i | startbit] 
DP[u1][2^u | startbit]
```

```
작은쪽에서 큰쪽으로 전이 해야겠지??
```

#### 2). 유형
##### ① TSP 외판원 순회 유영
##### ② 격자형 상태.

`DP[j][i][bit("여기로 도착하기 전에 어떤 배치였는가.")]`

`DP[i][j][bit | 2^0 | 2^1]` 이런..

#### 3). 예제
```cpp
DP상태는 [N][2^N]
간선 유무 체크하기 & 이미 방문한 정점인지 체크


```

제한은 $n<=20$ 그 이상은 메모리 초과남ㅋㅋㅋ

트릭은. u1에 도착했으면 항상 다음 상태로 넘어갈때, u1의 비트만 켜지는게 자명하다면.
DP배열을 압축해도 된다.

```cpp
발전소,

고장난 안난 점을 사용해서 고장난 정점을 고친다는것인데.
이건 X->Y 로 상태전이하는 그래프와 비슷하고,
이 전이되면서 w만큼의 값이 든다는것이다.

int tmp = G[w][e] + recursion(...);
DP[i][bit|2^i] DP[j][bit|2^j] 
```

---

> ### 📄 2. Tree DP

#### 루트를 잡고 서브트리 값들을 저장한 뒤, 부모 값을 자식 값들의 합성으로 만든다.

---

#### 1). Tree DP 개념 정리

##### ① 루팅
* 트리에서 루트를 정할때 아무 정점을 선택해도 된다. 그리고 거기서 부터 부모-자식의 관계를 본다.

##### ② 상태

* 상태 : 보통 정점 `v`의 서브트리에 대한 정보를 담는다. 
  * `DP[V]` V를 root로 하는 서브트리.. 이런식으로 상태 정의한다면
  * `DP[V]` 서브트리다. `DP[vleft]` 도 서브트리고.. `DP[vright]` 도 서브트리
  * 크기
  * 높이
  * 독립집합 최댓값 등.


##### ③ 합성

* 합성 : 부모의 값은 곧 자식들의 DP를 합성한 것이다
   * "자식들의 합", 
   * "자식들중 최소"
   * "자식들중 최대"

#### 2). 상태 설계와 초기화

##### ① 표기 

* `DP[v]` 또는 여러 상태일때는 `DP[v][state]`.

##### ② 형태

* 스칼라 : `size[v]`, `height[v]`
* 다상태 : `DP[v][0/1]` 채택/비채택, `DP[v][color]` 

##### ③ 초기화

* 바텀업, 탑다운 방식의 초기화가 있겠네.
* 그런데 대부분 **바텀업 방식**으로 초기화 되는것이 일반적이란다.

1. **case 1 바텀 업으로 전이** : 
   * `DP[parent]`를 구하기 위해서는 `DP[child_1], DP[child_2], DP[child_3]`가 필요하겠다. 
     ```cpp
     /* 서브트리 높이 */
     height[v] = 0; // 리프
     height[v] = 1 + max_element(height_v_child.begin(), height_v_child.end());
     ```
     ```cpp
     /* 서브 트리 크기 */
     size[v] = 1;
     for(auto e : G[v]) {
        size[v] += size[e];
     }
     ```
2. **case 2 탑다운 전이** 
   * `DP[child]`를 구하기 위해서는 `DP[parent]`가 필요하겠다.

#### 3). 문제 해결핵심과 절차

트리 DP로 풀꺼면 Leaf 노드부터 초기화 하고
바텀 업으로 부모의 값을 설정하자는 마음가짐입다.

그리고 DP를 구성한 뒤라면, DFS로 그래프 탐색을 하라는것

##### 근데 뭐가 Leaf 인지 알수 있을까?

* DFS(post-order): 자식 먼저 방문 -> 자식 DP로 부모 DP 갱신.

##### 절차

1. 인접 리스트 트리 생성
2. 루트 선택(아무 정점) 
3. DFS post-order 순회, 즉, 자식의 DP를 계산한 뒤 부모 DP 갱신

#### 4). 실수 방지

1. 합이어야 할 곳에 max를 넣지 말자
2. 부모 자식 구분 없이, 양방향으로 DP 누즉은 하면 안된다.
   ```cpp
   if(to == parent) continue;
   ```
3. 재귀 깊이 크면 반복 DFS를 고려해라
4. 값 범위 크면 long long

----

```
우수 마을 
DP[V][op]
혹은
struct E {
    int val;
    int op;
}
E DP[V]

op는 V 마을이 우수 마을의 선정 여부에 대한 bool 값. 

DP의 리프까지 재귀 호출해서 값을 채워준다.

전이 가능 판단은 이렇게만.
DP[par][1] <- DP[child][0]
DP[par][0] <- DP[child][1]

DP[par][1] = sum(DP[child][0] && [0] != 1) + A[par]

DP[par][1] = 
    sum(
        max(
            DP[child][0], // 우수마을 선택 안한것중 최댓값 얘가 더 클수도 있고
            DP[child][1] //  우수마을 선택한것 중 최댓값 얘가 더 클수도 있다.
        )
    )
```

```
트리의 독립집합 == 우수마을이랑 거희 같다는것..
조금 다른것은 DP 해를 출력해야 한다.
DP 역추적이 쓰인단다.

1.  DP가 확정(선택)되었을때 사용했던 어떤 정보가 있을것이다.
    그 타이밍에.. 선택플래그를 적어 내자.
    그러면 플래그에 적어 냈을때 어떤 정보를 같이 딸려왔어야 했나.
    바로 DP[par]에다가 선택 이력을 같이 저장해줬야 했다.
    최종적인 값을 구하느라 사용했던 정보를 
2. 예를 들어 (U_1, 1) 이 더 컸다면 그 노드를 또 파고 들어서 컸던 녀석을 또 찾자.
```

```
로스팅하는 엠마도 바리스타입니다 
좀 특이한게 모든 정점에서 다~~~~~~ 구해야 한다고 한다 : 리루팅 테크닉

그런데 한번 DP를 수행하고 나면 싹 구해놓고,
나머지 아무 정점들의 시작했다 하더라도, 추정이 가능한가 보다?

dp[u1]이라고 예를 들면 u1으로 가는 모든 경로가 계산된 데이터를 담았다..
dp[u1-1] 뿐만 아니라 dp[u1-2], ... 이미 지나쳐 온것도 경유한 녀석들 까지 모두.

DP_2[u] =   - (siz[v] * "u_v간선" + dp[v]) 
            + (w * (n-siz[v]) + dp[v])
```

```cpp
void DFS(int v, int b=0); // 첫번쨰 쓰는 디피
void DFS1(int v, int di, int b=0); 
    dist_sum[v] = dist_sum[b] + (cnt[b] - cnt[v])*di;
int main();
```

> ### 📄 3. DP 역추적

