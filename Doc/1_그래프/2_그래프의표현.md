> ### 📄 Graph의 표현

#### 1). 인접 행렬

* 메모리: $O(n^2)$
	$n \times n$ : vertex 수만큼 행, 렬을 준비하기
* 이웃 순회: $O(n)$ (비효율적, $deg(v)$ 대비)
* 간선 존재 검사: $O(1)$
	`M[N][M] == edge`

```cpp
vector<vector<int>> G
```

#### 2). 인접 리스트

* 메모리: $O(n + m)$
  vertex 수만큼 $n$개의 리스트
  한 정점에 대한 리스트 크기는 바로 $deg(v)$이다. 이게 곧 v의 edge의 개수인것.
* 이웃 순회: $O(deg(v))$
  $M[N].Foreach()$
* 간선 존재 검사: $O(deg(v))$
  `find(M.begin(), v.end(), num)`

```cpp
#define Vtx first
#define Wgt Second

typedef pair<int, int> PEdge;

struct SEdge {
	int vertex;
	int weight;
}

// 간선이 없으면 -1 또는 MAX 같은 아주 큰 값
vector<list<int>> G;
vector<map<int, int>> G;
```

```cpp

typedef struct Edge {
	int to;
	int w;
}

int MAX_V = 0;

vector<Edge> g[MAX_V + 1]; // zero index는 없는것으로 간주.
int edges_count(int v) {return g[v].size(); };
int vertices_count() { return g.size(); }
bool is_directed;

void insert_edge(int x, int y, int w, bool directed) {
	Edge nedge;
	nedge.to = y;
	nedge.w = w;
	g[x].push_back(nedge);
	if(!directed)
		insert_edge(y, x, w, true);
}

void remove_edge(int x, int y, bool directed = false) {
	auto rm_it1 = remove_if(g[x].begin(), g[x].end(),
		[](const Edge& e) -> bool {return e.to == y});
	g[x].erase(rm_it1, g[x].end());

	edge rm_edge = *rm_it;
	if(!directed) {
		auto rm_it2 = remove_if(g[y].begin(), g[y].end(),
			[](const Edge e) -> bool {return e.to == x});
		g[y].erase(rm_it2, g[y].end());
	}
}
```

#### 3). Bitset
* 인접행렬의 발전 형태
* 메모리: $ \frac{n^2}{자료형의비트수}$

```cpp
short board44 = 0;

bool at(short& board, int y, int x) {
	int row = 4 * y;
	int col = x;
	int pos = (1 << (row+col));
	return (board & pos) == pos;
}

void set(short& board, int y, int x, bool val) {
	int row = 4 * y;
	int col = x;
	int pos = (1 << (row+col));
	if(val)
		board |= pos;
	else 
		board &= ~pos;
}
```

#### 결론

| 비교 상황                                       | 승자                               |
| ----------------------------------------------- | ---------------------------------- |
| 두 정점을 잇는 에지 $e = (x, y)$ 가 존재성 판단 | 행렬 $O(1)$                        |
| 정점의 이웃 정점을 순회할때                     | 리스트 $O(deg(v)$                  |
| 회소 간선 VS 조밀 간선의 메모리                 | 리스트 $O(n + m)$ VS 행렬 $O(n^2)$ |
| 간선의 추가와 삭제                              | 행렬 $O(1)$                        |
| 그래프 탐색                                     | 리스트 $O(n + m)$ VS 행렬 $O(n^2)$ |

#### 4). 제 4의 방법

* 15 퍼즐이나, 바둑, 체스판 같은 보드 상태가 정점인 경우에는
경우의 수가 매~~~우 많아질 것이다.

----

